<section class="doc-section level-1"><h2 id="_tasks-to-solve"><a class="anchor" href="#_tasks-to-solve" aria-hidden="true"></a>Tasks to Solve</h2><section class="doc-section level-2"><h3 id="step"><a class="anchor" href="#step" aria-hidden="true"></a>Evaluate a lambda expression I, II, III</h3><div class="ulist"><ul><li>Evaluate a lambda expression (find a Normal Form) of these expressions.</li><li>Make sure to keep the same evaluation strategy from start to finish.</li><li>Write each step of the evaluation to the text file.</li><li>Each and every step needs to go on its own line in the text file.</li><li>The testing environment will reject an evaluation doing multiple beta-reductions at once.</li></ul></div>
<div class="table-block"><table class="frame-all grid-all stretch"><colgroup><col style="width: 65.3465%;"><col style="width: 17.8217%;"><col style="width: 16.8318%;"></colgroup><thead><tr><th class="halign-left valign-top">Expression</th><th class="halign-left valign-top">Strategy</th><th class="halign-left valign-top">File</th></tr></thead><tbody><tr><td class="halign-left valign-top"><code>(λ x y y . x ( x y y ) x) ( y x ) ( x x )</code></td><td class="halign-left valign-top">Normal Order</td><td class="halign-left valign-top"><code>eval1.txt</code></td></tr><tr><td class="halign-left valign-top"><code>(λ x y s z . x s ( y s z )) (λ s z . s z) (λ s z . s ( s z ))</code></td><td class="halign-left valign-top">Normal Order</td><td class="halign-left valign-top"><code>eval2.txt</code></td></tr><tr><td class="halign-left valign-top"><code>(λ a b . g a a b) ( (λ k l . k k l) (λ i . i) o ) d</code></td><td class="halign-left valign-top">Applicative Order</td><td class="halign-left valign-top"><code>eval3.txt</code></td></tr></tbody></table></div></section>
<section class="doc-section level-2"><h3 id="logic"><a class="anchor" href="#logic" aria-hidden="true"></a>Lambda function for boolean expression</h3><p>Write a lambda function <strong>in the Normal Form without using any Macros</strong> that implements the following boolean expression:</p>
<p><code>(x &amp;&amp; (! y)) || (! (x || y))</code></p>
<p>(where <code>!</code> is NOT, <code>&amp;&amp;</code> is logical <code>AND</code> a <code>||</code> is logical OR).</p>
<p><code>x</code> a <code>y</code> are arbitrary boolean expressions.</p>
<p>Write just the corresponding lambda function into the file <code>boolOp.txt</code>.</p>
<p>Tests (where <code>OP</code> represents your solution):</p>
<div class="ulist"><ul><li><code>OP T F</code> = <code>T</code></li><li><code>OP T T</code> = <code>F</code></li><li><code>OP F F</code> = <code>T</code></li><li><code>OP F T</code> = <code>F</code></li></ul></div></section>
<section class="doc-section level-2"><h3 id="logic_nand"><a class="anchor" href="#logic_nand" aria-hidden="true"></a>Lambda function for boolean operator NAND</h3><p>Write a lambda function in <strong>the Normal Form without using Macros</strong> that behaves like a binary NAND operator.</p>
<p>Write just the corresponding lambda function into the file <code>nand.txt</code>.</p>
<p>You can consult the definition of a <a href="https://en.wikipedia.org/wiki/Logical_NAND">NAND</a> on a wikipedia.</p>
<p>Tests (where <code>OP</code> represents your solution):</p>
<div class="ulist"><ul><li><code>OP T F</code> = <code>T</code></li><li><code>OP T T</code> = <code>F</code></li><li><code>OP F T</code> = <code>T</code></li><li><code>OP F F</code> = <code>T</code></li></ul></div></section>
<section class="doc-section level-2"><h3 id="math"><a class="anchor" href="#math" aria-hidden="true"></a>Lambda function doing arithmetics</h3><p>Write a lambda function in <strong>the Normal Form without using Macros</strong> that behaves like the following mathematical function:
<span class="math" data-lang="tex"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mn>2</mn><mo>⋅</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x, y) = 2 \cdot (x + 2) + y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span>.</p>
<p>You write the lambda function into the file <code>math.txt</code>.</p>
<p>Tests (where <code>FOO</code> represents your solution):</p>
<div class="ulist"><ul><li><code>FOO 0 0</code> = <code>4</code></li><li><code>FOO 0 1</code> = <code>5</code></li><li><code>FOO 2 5</code> = <code>13</code></li><li><code>FOO 3 2</code> = <code>12</code></li></ul></div></section>
<section class="doc-section level-2"><h3 id="isAnd"><a class="anchor" href="#isAnd" aria-hidden="true"></a>isAnd</h3><p>Write a lambda function that tests whether its argument (let&#8217;s call it <code>FOO</code>) <strong>behaves the same way like</strong> the operator <code>AND</code> for boolean expressions <code>T</code> and <code>F</code>.</p>
<p>In other words, your function needs to test whether <code>FOO T T</code> evaluates to <code>T</code>, <code>FOO T F</code> evalautes to <code>F</code> and so on.</p>
<p><strong>You may use macros for boolean expressions (<code>F</code>, <code>T</code>, <code>AND</code>, <code>NOT</code>, &#8230;&#8203;).</strong></p>
<p>Tests (where <code>ISAND</code> represents your solution):</p>
<div class="ulist"><ul><li><code>ISAND (λ x y . x y x)</code> = <code>T</code></li><li><code>ISAND (λ x y . x T y)</code> = <code>F</code></li><li><code>ISAND (λ x y . x)</code> = <code>F</code></li></ul></div>
<p>You write the lambda function into the file <code>isAnd.txt</code>.</p></section>
<section class="doc-section level-2"><h3 id="recursion"><a class="anchor" href="#recursion" aria-hidden="true"></a>Recursive Function</h3><p>Write a lambda function for the following recrusive function:</p>
<div class="ulist"><ul><li><span class="math" data-lang="tex"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(0, 0) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></li><li><span class="math" data-lang="tex"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>m</mi><mo>+</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(0, m) = m + f(0, m - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li><li><span class="math" data-lang="tex"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mn>0</mn><mo>)</mo><mo>=</mo><mi>n</mi><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n, 0) = n + f (n - 1, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></li><li><span class="math" data-lang="tex"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n, m) = f(n, m - 1) + f(n - 1, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></li></ul></div>
<p><strong>You may use macros <code>ZERO</code>, <code>+</code>, <code>-</code>, and numbers in your solution.</strong></p>
<p>Tests (where <code>R</code> represents your solution):</p>
<div class="ulist"><ul><li><code>Y R 0 0</code> = <code>1</code></li><li><code>Y R 0 1</code> = <code>2</code></li><li><code>Y R 0 2</code> = <code>4</code></li><li><code>Y R 1 0</code> = <code>2</code></li><li><code>Y R 1 1</code> = <code>4</code></li><li><code>Y R 1 2</code> = <code>8</code></li><li><code>Y R 2 0</code> = <code>4</code></li><li><code>Y R 2 1</code> = <code>8</code></li><li><code>Y R 2 2</code> = <code>16</code></li></ul></div>
<p>You write the expression <code>R</code>, representing the function <code>f</code> from the math definition above, into the file <code>recursion.txt</code>.
Your written solution/function will be tested as a part of the expression <code>Y R args&#8230;&#8203;</code>, where <code>R</code> is your submitted function, <code>Y</code> and <code>args..</code> will be supplied by the testing environment.
<strong>Do not submit</strong> expression starting with the <code>Y-combinator</code> or else your solution will loop forever.</p></section>
<section class="doc-section level-2"><h3 id="isEven"><a class="anchor" href="#isEven" aria-hidden="true"></a>isEven</h3><p>Write a lambda function that tests wheter a number given to it is <strong>even</strong>.</p>
<p>Tests (where <code>ISEVEN</code> represents your solution):</p>
<div class="ulist"><ul><li><code>ISEVEN 0</code> = <code>T</code></li><li><code>ISEVEN 1</code> = <code>F</code></li><li><code>ISEVEN 2</code> = <code>T</code></li><li><code>ISEVEN 3</code> = <code>F</code></li><li><code>ISEVEN 4</code> = <code>T</code></li></ul></div>
<p>You write the lambda expression into the file <code>isEven.txt</code>.</p></section></section>