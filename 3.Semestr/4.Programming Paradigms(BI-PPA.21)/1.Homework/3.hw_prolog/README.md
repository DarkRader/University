<section class="doc-section level-1"><h2 id="_task-assignment"><a class="anchor" href="#_task-assignment" aria-hidden="true"></a>Task Assignment</h2><section class="doc-section level-2"><h3 id="btidentical"><a class="anchor" href="#btidentical" aria-hidden="true"></a>Structurally the Same Binary Trees</h3><p>The Binary Tree is represented as</p>
<div class="ulist"><ul><li>atom <code>empty</code>, if the tree is empty, or</li><li>as <code>t(V, L, R)</code>, where <code>V</code> is a value in the given vertex of the tree and <code>L</code> and <code>R</code> are the left, resp. the right sub-tree.</li></ul></div>
<p>Write a predicate <code>bt_identical(+-T1, +-T2)</code> that decides whther two trees <code>T1</code> and <code>T2</code> are structurally the same. In other words, specific values in those trees might differ, but the shape is exactly the same.</p>
<div class="ulist"><ul><li><code>bt_identical(empty, empty).</code> &#8594; <code>true.</code></li><li><code>bt_identical(not_a_tree, empty).</code> &#8594; <code>false.</code></li><li><code>bt_identical(t(1, empty, empty), t(2, empty, empty)).</code> &#8594; <code>true.</code></li><li><code>bt_identical(t(1, t(2, empty, empty), empty), t(1, empty, empty)).</code> &#8594; <code>false.</code></li><li><code>bt_identical(t(1, t(2, empty, empty), empty), Tree).</code> &#8594; <code>Tree = t(_, t(_, empty, empty), empty).</code></li><li><code>bt_identical(t(1, t(2, empty, t(3, empty, t(4, empty, empty))), empty), t(2, Left, Right)).</code> &#8594; <code>Left = t(_, empty, t(_, empty, t(_, empty, empty))), Right = empty.</code></li><li><code>bt_identical(t(4,3,2), Tree).</code> &#8594; <code>false.</code></li></ul></div></section>
<section class="doc-section level-2"><h3 id="valuesin"><a class="anchor" href="#valuesin" aria-hidden="true"></a>Values in the List</h3><aside class="admonition-block tip" role="doc-tip"><h6 class="block-title label-only"><span class="title-label">Tip: </span></h6><p>A smart use of the predicate <code>member</code> can make the task significantly easier.</p></aside>
<p>Write a predicate <code>values_in(+-Values, +Universe)</code> that decides whther a list <code>Values</code> contains only elements of the list <code>Universe</code>. You can rely on <code>Universe</code> being always a list.</p>
<div class="ulist"><ul><li><code>values_in([], [1,2,3,4,5,6,7,8,9]).</code> &#8594; <code>true.</code></li><li><code>values_in([1,2,3,2,1], [1,2,3,4,5,6,7,8,9]).</code> &#8594; <code>true.</code></li><li><code>values_in([1,2,3,2,1], []).</code> &#8594; <code>false.</code></li><li><code>values_in([], []).</code> &#8594; <code>true.</code></li><li><code>values_in([aag,ppa,ag1,youShallNotPass,ma2], [ma2,aag,ppa,ag1]).</code> &#8594; <code>false.</code></li><li><code>values_in([a,b,X,Y,c], [a,b,c]).</code> &#8594;<ul><li><code>X = Y, Y = a ;</code></li><li><code>X = a, Y = b ;</code></li><li><code>X = a, Y = c ;</code></li><li><code>X = b, Y = a ;</code></li><li><code>X = Y, Y = b ;</code></li><li><code>X = b, Y = c ;</code></li><li><code>X = c, Y = a ;</code></li><li><code>X = c, Y = b ;</code></li><li><code>X = Y, Y = c ;</code></li><li><code>false.</code></li></ul></li><li><code>length(Lst, 2), values_in(Lst, [1,2,3]).</code> &#8594;<ul><li><code>Lst = [1, 1] ;</code></li><li><code>Lst = [1, 2] ;</code></li><li><code>Lst = [1, 3] ;</code></li><li><code>Lst = [2, 1] ;</code></li><li><code>Lst = [2, 2] ;</code></li><li><code>Lst = [2, 3] ;</code></li><li><code>Lst = [3, 1] ;</code></li><li><code>Lst = [3, 2] ;</code></li><li><code>Lst = [3, 3].</code></li></ul></li><li><code>findall(E, between(1, 16, E), Universe), length(Lst, 3), values_in(Lst, Universe).</code> &#8594;<ul><li><code>Universe = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], Lst = [1, 1, 1] ;</code></li><li><code>Universe = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], Lst = [1, 1, 2] ;</code></li><li><code>Universe = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], Lst = [1, 1, 3] ;</code></li><li>&#8230;&#8203;</li><li><code>Universe = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], Lst = [16, 16, 16].</code></li></ul></li></ul></div></section>
<section class="doc-section level-2"><h3 id="secondmin"><a class="anchor" href="#secondmin" aria-hidden="true"></a>Deletion of the Second Smaller Element from the List</h3><p>Write a predicate <code>without_second_min(+Lst, -Res)</code> that, for a list of numbers <code>Lst</code>, "returns" a list of numbers such that it does not contain any occurences of the second smallest number from the original list <code>Lst</code>.</p>
<p>If the <code>Lst</code> does not contain at least two numbers, the predicate should fail.</p>
<div class="ulist"><ul><li><code>without_second_min([1,2,3,2,1], R)</code> &#8594; <code>R = [1,3,1].</code></li><li><code>without_second_min([1,1], R)</code> &#8594; <code>false.</code></li><li><code>without_second_min([1], R)</code> &#8594; <code>false.</code></li><li><code>without_second_min([], R)</code> &#8594; <code>false.</code></li><li><code>without_second_min([-5, -5, -5], R)</code> &#8594; <code>false.</code></li><li><code>without_second_min([-5, -5, -10, -5, -10], R)</code> &#8594; <code>R = [-10, -10].</code></li></ul></div>
<section class="admonition-block important" role="doc-notice"><h6 class="block-title label-only"><span class="title-label">Important: </span></h6><p>Make sure that your predicate gives exactly single answer. An implementation giving more than one will be considered incorrect and will not pass the test.</p></section></section>
<section class="doc-section level-2"><h3 id="game"><a class="anchor" href="#game" aria-hidden="true"></a>Can X Defend its Territory?</h3><section class="admonition-block important" role="doc-notice"><h6 class="block-title label-only"><span class="title-label">Important: </span></h6><p>For this task, it does not matter how many answers your implementation gives. Only the first one is considered.</p></section>
<p>Write a predicate <code>can_x_defend(+List).</code> that makes a judgement about a possible outcome of a game with a given game board setting.</p>
<p>This is a simple game for two players. They play in turns and a player named <code>X</code> begins.
The player <code>X</code> is the one defending, the player named <code>O</code> is invading.</p>
<p>The board is represented as a single row of tokens.
Every token is marked with a symbol of one of two players.
That means there are tokens marked <code>x</code> or <code>o</code>.</p>
<p>The game&#8217;s rules are simple:</p>
<div class="ulist"><ul><li>The player <code>X</code> begins.</li><li>The player whose turn it is picks up one or more of their uncovered tokens.</li><li>The player whose turn it is can pick up multiple tokens only if they all are directly in succession.</li><li>A token is considered uncovered if it does not have another token on at least one of its two sides.</li><li>If the player whose turn it is does not have an uncovered token to pick up, they are skip the turn.</li></ul></div>
<p>The game ends when <code>X</code> successfuly defends their territory or when <code>O</code> conquers it. That is, when one of the players picks up a last token with their mark from the board.</p>
<div class="ulist"><ul><li>We say that <code>X</code> defended if they removed all of their tokens from the board before <code>O</code> done the same.</li><li>We say that <code>O</code> won if they removed their last token from the game board and there are still some `X&#8217;s tokens left (even one counts).</li></ul></div>
<p>Predicate is provable in the case when <code>X</code> can defend its territory for any combination of `O`s moves.</p>
<div class="ulist"><ul><li><code>can_x_defend([o,o]).</code> &#8594; <code>true.</code></li><li><code>can_x_defend([x,x]).</code> &#8594; <code>false.</code></li><li><code>can_x_defend([x,x,o,o]).</code> &#8594; <code>true.</code></li><li><code>can_x_defend([x,o,o,x,x,o,x,o,o,x]).</code> &#8594; <code>false.</code></li><li><code>can_x_defend([o,o,x,x,x,x,o,o]).</code> &#8594; <code>true.</code></li><li><code>can_x_defend([o,x,x,o,o,x,x,x,o]).</code> &#8594; <code>true.</code></li><li><code>can_x_defend([x,o,x,x,o,x,o,x,x,o,x,x,o,x]).</code> &#8594; <code>false.</code></li></ul></div></section>
<section class="doc-section level-2"><h3 id="numbers"><a class="anchor" href="#numbers" aria-hidden="true"></a>Numbers</h3><p>Write a predicate <code>numbers(+Lst, +Target)</code> that decides if the numbers in the list <code>Lst</code> and operations <code>+</code>,<code>-</code>,<code>*</code> and <code>/</code> can be used to obtain a value <code>Target</code>.
Every number can be used <strong>at most</strong> once.</p>
<p>For example <code>numbers([25, 50, 7, 3], 200)</code> is truthful proposition because <code>(7-3)*50 = 200</code>. And <code>numbers([50, 70], 50)</code> is truthful because <code>50</code> is already in the list.</p>
<p>You can use division only if the result of dividing two numbers is an integer (for example <code>5/5</code>, <code>10/2</code> or <code>20/5</code>, but not <code>2/5</code> or <code>2/10</code>).</p>
<p>You can make sure that two numbers can be divided with an integral result using a predicate <code>mod/2</code> (<code>X is mod(5, 2)</code>).</p>
<p>You can rely on <code>Target</code> being an integer bigger than <code>1</code> and <code>Lst</code> containing only positive integers (above zero).</p>
<p>We only care if there <strong>IS</strong> a solution, not what is it nor how many of them there are.</p>
<aside class="admonition-block tip" role="doc-tip"><h6 class="block-title label-only"><span class="title-label">Tip: </span></h6><p>A smart use of the <code>member</code> predicate can make this task significantly easier.
The solution is really "silly" backtracking: try all the possible combinations of pairs of numbers and compose those into a partial-results then use that in the future computation.</p></aside>
<section class="admonition-block important" role="doc-notice"><h6 class="block-title label-only"><span class="title-label">Important: </span></h6><p>Note that in the samples below we use parentheses for priority in arithmetic expressions.
Please make sure that your solution can work with priorities, e.g. try a query <code>numbers([70,50,33,44], 220).</code>. Such query is solvable with computation <code>(70-50)*(44-33) = 220</code>.
If you only pick one number and add it to some kind of accumulator then you won&#8217;t be able to solve queries like this one.</p></section>
<section class="admonition-block important" role="doc-notice"><h6 class="block-title label-only"><span class="title-label">Important: </span></h6><p>The testing environment wraps the invocation of <code>numbers(Lst, Target)</code> in a special predicate that assures that <code>numbers</code> will not backtrack after it finds a first answer.
You can try such a predicate on your computer:</p>
<div class="listing-block"><pre class="highlightjs-ext highlight"><code>onlyfirst(Goal) :- Goal, !.

?- numbers([25, 50, 7, 3], 200).
true ;
true ;
...

?- onlyfirst(numbers([25, 50, 7, 3], 200)).
true.</code></pre></div></section>
<div class="ulist"><ul><li><code>numbers([1,2,3], 7)</code> &#8594; <code>true.</code> (cause <code>1 + 3 * 2 = 7</code>)</li><li><code>numbers([3,4,1,2], 7)</code> &#8594; <code>true.</code> (cause <code>4 + 3 = 7</code>)</li><li><code>numbers([1,7,7,3], 24)</code> &#8594; <code>true.</code> (cause <code>(7 - 3) * (7 - 1) = 24</code>)</li><li><code>numbers([75, 50, 2, 3, 8, 7], 812)</code> &#8594; <code>true.</code> (cause <code>(50 + 8) * 7 * 2 = 812</code>)</li><li><code>numbers([50, 10, 6, 25, 100, 75], 50)</code> &#8594; <code>true.</code> (cause <code>50</code> already in the list, or cause <code>100 - 50 = 50</code>, <code>100 - 75 + 25 = 50</code>, &#8230;&#8203;))</li><li><code>numbers([50, 10, 6, 25, 100, 75], 463)</code> &#8594; <code>true.</code> (cause <code>((75 - (100 / 50)) * 6) + 25 = 463</code> or something like <code>(50 + 10) × 6 + 100 + (75 / 25) = 463</code>)</li><li><code>numbers([50, 10, 6, 25], 463)</code> &#8594; <code>false.</code> (the closest possible result is 465)</li><li><code>numbers([50, 10, 6, 25], 17)</code> &#8594; <code>false.</code></li><li><code>numbers([], 1)</code> &#8594; <code>false.</code></li><li><code>numbers([75,75,10,8,10], 998)</code> &#8594; <code>false.</code></li></ul></div></section>
<section class="doc-section level-2"><h3 id="trilist"><a class="anchor" href="#trilist" aria-hidden="true"></a>Trilist</h3><p>Write a predicate <code>trilist(Lst)</code> that decides whether a list <code>Lst</code> consists of a short sequence repeated three times.</p>
<aside class="admonition-block tip" role="doc-tip"><h6 class="block-title label-only"><span class="title-label">Tip: </span></h6><p>It is recommended to start with a simpler predicate that checks whether a list consists of a short sequence repeated twice.</p></aside>
<div class="ulist"><ul><li><code>trilist([a,2,a,2,a,2])</code> &#8594; <code>true.</code></li><li><code>trilist([1,2,1,2])</code> &#8594; <code>false.</code></li><li><code>trilist([1,2,1,2,1,2,1,2])</code> &#8594; <code>false.</code></li><li><code>trilist([1,2,3,1,2,4])</code> &#8594; <code>false.</code></li><li><code>trilist([1,2,3,4,5,1,2,3,4,5,1,2,3,4,5])</code> &#8594; <code>true.</code></li><li><code>trilist([1,1,1])</code> &#8594; <code>true.</code></li><li><code>trilist([])</code> &#8594; <code>true.</code></li><li><code>trilist([1,1])</code> &#8594; <code>false.</code></li><li><code>trilist([1])</code> &#8594; <code>false.</code></li><li><code>trilist([1,X,1,X,1,X])</code> &#8594; <code>true.</code></li><li><code>trilist([1,X,1,X])</code> &#8594; <code>false.</code></li><li><code>trilist([1,X,1,X,Y,2])</code> &#8594; <code>X = 2, Y = 1.</code></li></ul></div></section></section>