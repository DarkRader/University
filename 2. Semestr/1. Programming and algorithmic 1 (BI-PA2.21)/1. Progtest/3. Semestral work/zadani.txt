= Kalkulačka s neomezenou přesností
Autor: Artem Kuznetsov

== Zadání

Můj úkol bude realizovat kalkulačku s neomezenou přesností. Kalkulačka bude schopná pracovat s celými i desetinnými čísly a vypolňovat základní operace: sčítaní, odsčítaní, násobení a dělení, ale jen pro celé čísla (bude brát v úvahu zbytek). Navíc kalkulačka bude moct nejen provadět operace s čísly i zároveň zapsat výsledek do proměnné a pak využit proměnné ve výpočtu.

Uživatel může v době použítí kalkulačkou použít jakýkoli z navrhovaných operatoru pro operací popsané výše: `+`, `-`, `*`, `/`, `()`, přičemž závorky můžou být ve výrazu libovolně vnořené.

Aby kalkulačka byla více užitečná uživatel může uložit ji stav (například proměnné a historií) do souboru a v případě potřebe znovu načíst.

== Specifikace

Podle mé představy stahovaní bude fungovat tak, že užívatel může snadno stahnout všichni operaci, a tí zapíšou do odděleného souboru přesné tak, jak bylo zapsáno do kalkulačky(to bude zapsán do souboru současně při zápisu do kalkulačky, aby se všechny tyto údaje nebyli uloženy v paměti), pak přínačtení znovu program bude zpracovat stažený soubor stejně jak to dělal při zpracovaní s užívatelem. Přitom při načtení program zapíse promenné do svých objektu v třídech, aby dál mohl s nimi pracovat.

Program nebude použivat žadný grafické rozhraní a všichni operace budou zpracovány přímo v terminálu. Pokud uživatel bude chtít stahnout historku nebo proměnnu kalkulačky(pro to potřebuje jen propsát commandu stahnout nebo stahnout "nazev proměnny"(uživatel může nápsat několik proměnných najednou)), udělám program tak, aby všichni stažený soubory byli ukladány do adresáře stahování na počítači. Naopak, v případě, že uživatel bude chtít načíst soubor s operacemi, bude stačít uložit ténto soubor v adresář s programem. Po ukončení programu, všichni zbytečné soubory v sloužce programu budou odstraněny.

Program potřebuje parsovat data, aby vědet s čím musí pracovat a s jaké třídy bude volat pro další práci. Protože uživatel může psát cokoliv v terminalu, program bude muset detekovat a výpisovat chybu, pokud syntaxe nebude správně nápsana. Na začatku programy bude nápsano co uživatel musí psát, aby kalsulačka fungovala spravně.

== Polimorfismus

V mém programu budu přepokladat použít 2 hierarchie tříd, které budou splňovat podmínky na polimorfismus. Konkrétně třídy na práci s cislami jsou poměrně velké a práce s obrovskými čísly. Pro práci s proměnnými program bude mít samostatnou třídu, s které bude volat jednu z skupin výše uvedené. Bude mít methods `findVariable`, které se bude zabyvat tím, aby vypočítat proměnnou a uložít jí do objektu třídy a navíc zachovat všechno co obsahuje táto proměnna do druhého objekta třidy. Proměnna bude samostatnou instancí třídy.

Poměrně velké čísla

V této skupině tříd budu mít jednu rodičovsku třídu (`CType`) a dvě zdědiné třídy(`CInteger` a `CFloat`), které budou reprezentovat typ, s kterým program bude pracovat. Konkřetně budu mít v programu dva takzvaných typu: celé čísla(prezentovány pomocí long long int), desetinné čísla(prezentovány pomocí long double). To není typy dat doslova, ale spíše mé vlastní type dat, kterými budou jmenovat třídy. V každé zdědiné třídě budou výpočitat čísla svým způsobem, ale navíc výsledek po operacích bude ukladat svůj výsledek do promměnných rodičovské třídy(pro int a float respektive), aby možné bylo ji použít dál při výpočtu. Počty budou probíhat za pomoci operátorů `+`, `-`, `*`, `/`, `()`, které budou virtualní v rodičovské třídě a přepsany v zdědiných třídech. Všechna táto skupina může pracovat jen s omezenými číslami, pokud dovoluje typ long long int u celých čísel a long double u desetinných. Větší čísla budou vyžadovat skupinu tříd, která to bude schopna vypočítat

Obrovské čísla

Cíl této skupiny úplně stějná, jako u predchozí, ale bude pracovat s číslami větší než to dovoluje long long int u celých čísel a double u desetinných. Pro čísla takovou velikostí potřebuju použít řetězec(velmi pravděpodobně práce s bity napřímo), aby program byl shopen reprezentovat velmi velká čísla. Rozhraní u této skupiny tříd bude podobné, ale místo operací s číslami operací budou s řetězci. Hierarchie tříd bude vypadat takto: rodičovska třída: `CTypeBig` a zdědiné třídy: `CIntegerBig` a `CFloatBig`
