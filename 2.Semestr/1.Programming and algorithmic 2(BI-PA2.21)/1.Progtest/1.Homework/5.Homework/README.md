<h1>Supermarket</h1>
<td class="lrtbCell" colspan="3" align="left"><p>The task is to implement classes that manage the inventory in a supermarket.</p>
<p>We assume a warehouse of goods in a supermarket. This warehouse contains a significant amount of merchandise. The goods are uniquely identified by their name (a string). You can assume that most product names have a reasonable length (e.g., up to 30 characters). Additionally, we keep track of the expiration date and the number of stocked units for each product.</p>
<p>In the warehouse (class <tt>CSupermarket</tt>), we want to perform the following operations, each implemented in a method:</p>
<dl>
  <dt>default constructor</dt><dd>initializes an empty instance of the warehouse,</dd>
  <dt>store(name, expireDate, cnt)</dt><dd>method restocks goods. The goods are identified by their name (<tt>name</tt>), expiration date (<tt>expireDate</tt>), and number of units (<tt>cnt</tt>). It is possible that goods restocked later may have a shorter shelf life than goods restocked earlier (even for goods with the same name).</dd>
  <dt>sell(list)</dt><dd>method processes a purchase. The parameter is a shopping list of type <tt>list&lt;pair&lt;string,int&gt;&gt;</tt> which contains product names and the desired quantity. The method goes through the warehouse, checks the availability of goods, adjusts the quantities in the warehouse, and updates the shopping list. The method is complicated by the fact that customers do not write neatly, and the software that handles OCR of shopping lists may misread some names. The implementation must account for this, so it uses the following procedure when searching for goods:
    <ul>
     <li>primarily, it looks for goods with an exactly matching name (case-sensitive),</li>
     <li>if no goods with an exact name match exist, it looks for goods with a name differing by one character - a typo (still case-sensitive). If it finds exactly one such product, it will select it,</li>
     <li>if it cannot find any such product (either no products differ by exactly one character, or multiple products differ by one character), no goods will be issued.</li>
    </ul>
    <p>If the goods are found, the <tt>sell</tt> method will always issue goods starting from the oldest (first getting rid of goods with the shortest shelf life). If the warehouse has a sufficient quantity of goods, the method will issue them and remove the item from the shopping list. If the warehouse does not have a sufficient quantity of goods, the method will issue the available amount and decrease the quantity in the shopping list by that amount.</p>
<p>When shopping, the method proceeds "transactionally": first, for each item on the list, it decides whether the goods exist (whether it finds them in the warehouse, or uniquely finds goods differing by only one character in the name) and only then begins issuing goods from the warehouse and updating the shopping list. This behavior is demonstrated at the end of the sample run, where when shopping for coca-cola (list <tt>l10</tt>), the name <tt>Cake</tt> is ambiguous, but for the subsequent sale (after the <tt>cake</tt> is sold out), it is unambiguous. The example with the list <tt>l14</tt> shows that the shopping list is updated in order from the first to the last item during the issue of goods.</p></dd>
</dl>
<p>Submit the source code with the implementation of the <tt>CSupermarket</tt> and <tt>CDate</tt> classes. Use the provided file with method declarations and a set of basic tests as the basis for the implementation. It may be useful to add other helper classes.</p>
<p>Notes:</p>
<ul>
 <li>In the mandatory test, the warehouse contains a relatively small amount of goods. A linear implementation should pass the mandatory tests. Other tests work with much larger volumes of data, where a linear implementation is insufficient. Such a solution will be heavily penalized in the optional test. To speed up, use associative containers from STL.</li>
 <li>Associative containers can easily be used for exact match searches. The optional test mostly works with correct product names, so a solution reasonably combining associative and linear search will pass this test. The bonus test works with a large volume of data and many incorrect product names. To pass it, you need to use associative containers creatively.</li>
 <li>The <tt>store</tt> and <tt>sell</tt> methods are called frequently and should be efficient. The <tt>expired</tt> method is called much less often, so its efficiency is not as critical. <b>NOTE:</b> if the method is grossly inefficient, it can cause a time limit to be exceeded. The returned list can be long, and a quadratic algorithm is too slow for such a length.</li>
 <li>You may/must use STL collections in the implementation. However, it is not reasonable to use the <tt>vector</tt> collection for all internal structures. If you want to use C++11 containers <tt>unordered_set / unordered_map</tt>, then do not derive the hash functor as a specialization of <tt>std::hash</tt>. Declare the hash function/functor explicitly when creating an instance of <tt>unordered_set / unordered_map</tt>. (Specialization of <tt>std::hash</tt> assumes reopening the <tt>std</tt> namespace, which is difficult if you are in another namespace. Instructions available on the internet (stack overflow, cpp reference) implicitly assume that namespaces are not used; the recommended solutions are not ideally compatible.)</li>
 <li>The bonus test requires high speed, whereas memory efficiency is not required. During the run, you have several times (3-5x) more memory than is necessary for storing product information. To achieve speed, you can (slightly) waste memory.</li>
 <li>A solution that passes all mandatory and optional tests with 100% can be used for code review (the solution does not have to pass the bonus test).</li>
</ul>     
</td>
